#!/usr/bin/env python3

import setup_path  # pylint: disable=unused-import
import sys
import socket
import random
import time
from threading import Thread, RLock
from queue import Queue
from lib import constants as Constants
from lib import util

_session_id = random.randint(0, 2**32)
_seq = 0
_socket: socket.socket = None
_server_address: "tuple[str,int]" = None
_close_lock = RLock()
_client_closing: bool = False
_waiting_message_time: int = -1


def send_packet(command: int, data: str = None):
    global _seq

    data_msg = util.pack(command, _seq, _session_id, data)
    _socket.sendto(data_msg, _server_address)
    _seq += 1


def closing_client():
    global _client_closing
    global _waiting_message_time

    with _close_lock:
        if not _client_closing:
            _waiting_message_time = time.time()
            send_packet(Constants.Command.GOODBYE.value)
            _client_closing = True


def handle_timer(finish_queue: Queue):

    while True:
        time.sleep(Constants.TIMEOUT_INTERVAL)
        if _waiting_message_time != -1 and time.time() - _waiting_message_time > Constants.TIMEOUT_INTERVAL:
            if not _client_closing:
                closing_client()
            else:
                break

    finish_queue.put(2)


def handle_keyboard():
    global _waiting_message_time

    while True:
        text = sys.stdin.readline()
        # Terminates server if input is EOF or "q"
        if not text or (text == "q\n" and sys.stdin.isatty()):
            closing_client()
            break
        else:
            if _waiting_message_time == -1:
                _waiting_message_time = time.time()
            send_packet(Constants.Command.DATA.value, text)


def handle_socket(finish_queue: Queue):
    global _waiting_message_time

    def log(session_id: int, seq: "int | None", msg: str):
        if seq is None:
            print(f"0x{session_id:08x} {msg}")
        else:
            print(f"0x{session_id:08x} [{seq}] {msg}")

    while True:
        packet, remote_addr = _socket.recvfrom(Constants.BUFFER_SIZE)

        magic_num, version, command, seq, session_id = util.unpack(packet)

        if magic_num == Constants.MAGIC_NUMBER:
            if command == Constants.Command.GOODBYE.value:
                log(session_id, seq, "GOODBYE from server.")
                break
            elif command == Constants.Command.ALIVE.value:
                if _waiting_message_time != -1:
                    _waiting_message_time = -1
            else:
                print(f"Invalid command: {command}")
                break

    finish_queue.put(0)


def hello_exchange():
    # stop and wait
    def try_hello_exchange():
        send_packet(Constants.Command.HELLO.value)
        done = False
        while not done:
            packet, remote_addr = _socket.recvfrom(Constants.BUFFER_SIZE)
            magic_num, version, command, seq, session_id = util.unpack(packet)
            if magic_num == Constants.MAGIC_NUMBER and version == Constants.VERSION:
                done = command == Constants.Command.HELLO.value

    t = Thread(target=try_hello_exchange, daemon=True)
    t.start()
    t.join(Constants.TIMEOUT_INTERVAL)
    return not t.is_alive()


def main():
    global _server_address, _socket

    hostname = sys.argv[1]
    portnum = int(sys.argv[2])
    _server_address = (hostname, portnum)
    _socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    if hello_exchange():
        finish_queue = Queue()

        t1 = Thread(target=handle_socket, args=(finish_queue,), daemon=True)
        t1.start()

        t2 = Thread(target=handle_keyboard, daemon=True)
        t2.start()

        t3 = Thread(target=handle_timer, args=(finish_queue,), daemon=True)
        t3.start()

        # blocks current thread until something found in queue
        finish_queue.get()

        try:
            _socket.shutdown(socket.SHUT_RDWR)
        except:
            pass
        _socket.close()
    else:
        print("Did not receive HELLO from server")


if __name__ == "__main__":
    main()
