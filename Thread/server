#!/usr/bin/env python3

import setup_path  # pylint: disable=unused-import
import sys
import socket
import time
from queue import Queue
from threading import Thread
from typing import Any
from lib import constants as Constants
from lib.structures import ClientData
from lib import util

_client_data_map: "dict[int, ClientData]" = {}
_seq = 0
_socket: socket.socket = None
_queue = Queue()
_server_done = False


def add_print_message(message: str):
    _queue.put(message)


def send_packet(command: int, session_id: int, destination: Any, data: str = None):
    global _seq

    data_msg = util.pack(command, _seq, session_id, data)
    _socket.sendto(data_msg, destination)
    _seq += 1


def server_close():
    global _server_done

    for session_id in list(_client_data_map.keys()):
        client_close(session_id)

    _server_done = True


def log(session_id: int, seq: "int | None", msg: str):
    if seq is None:
        add_print_message(f"0x{session_id:08x} {msg}")
    else:
        add_print_message(f"0x{session_id:08x} [{seq}] {msg}")


def check_client(session_id: int, seq: int):
    client = _client_data_map[session_id]
    if seq > client.packet_number + 1:
        for i in range(client.packet_number + 1, seq):
            log(session_id, i, "Lost packet!")
    elif seq == client.packet_number:
        log(session_id, seq, "Duplicate packet!")
    elif seq < client.packet_number:
        client_close(session_id)
        return False
    return True


def client_close(session_id: int):
    client = _client_data_map[session_id]
    send_packet(Constants.Command.GOODBYE.value, session_id, client.address)
    log(session_id, None, "Session Closed")
    del _client_data_map[session_id]


def print_queue_messages(limit: int = None):
    size = _queue.qsize() if limit is None else min(limit, _queue.qsize())
    output = ""
    for _ in range(size):
        output += _queue.get() + "\n"
    if len(output) > 0:
        sys.stdout.write(output)


def handle_print():
    while not _server_done:
        print_queue_messages()
        time.sleep(2)


def handle_keyboard():
    while True:
        text = sys.stdin.readline()
        # Terminates server if input is EOF or "q"
        if not text or (text == "q\n" and sys.stdin.isatty()):
            server_close()  # do gracefully end here
            break


def handle_timer():
    try:
        while True:
            for session_id in list(_client_data_map.keys()):
                client = _client_data_map[session_id]
                if client.timestamp != -1 and time.time() - client.timestamp > Constants.TIMEOUT_INTERVAL:
                    client_close(session_id)
            time.sleep(Constants.TIMEOUT_INTERVAL)
    except:
        pass


def handle_socket():
    try:
        while True:
            packet, remote_addr = _socket.recvfrom(Constants.BUFFER_SIZE)

            packet_header = packet[:Constants.HEADER_SIZE]
            magic_num, version, command, seq, session_id = util.unpack(packet_header)

            if magic_num == Constants.MAGIC_NUMBER and version == Constants.VERSION:
                if session_id in _client_data_map:
                    if not check_client(session_id, seq):
                        continue

                if command == Constants.Command.HELLO.value:
                    if session_id in _client_data_map:
                        client_close(session_id)
                        continue
                    _client_data_map[session_id] = ClientData(session_id, remote_addr)
                    send_packet(Constants.Command.HELLO.value, session_id, remote_addr)
                    log(session_id, seq, "Session created")
                    _client_data_map[session_id].timestamp = time.time()
                elif command == Constants.Command.DATA.value:
                    data = packet[Constants.HEADER_SIZE:].decode("utf-8", "replace").rstrip()
                    send_packet(Constants.Command.ALIVE.value, session_id, remote_addr)
                    log(session_id, seq, data)
                    _client_data_map[session_id].timestamp = time.time()
                elif command == Constants.Command.GOODBYE.value:
                    if session_id not in _client_data_map:
                        continue
                    send_packet(Constants.Command.GOODBYE.value, session_id, remote_addr)
                    log(session_id, seq, "GOODBYE from client.")
                    client_close(session_id)
                else:
                    add_print_message(f"Invalid command: {command}")
                if session_id in _client_data_map:
                    _client_data_map[session_id].packet_number = seq
    except:
        pass


if __name__ == "__main__":
    portnum = int(sys.argv[1])
    address = (b"0.0.0.0", portnum)
    _socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    _socket.bind(address)

    add_print_message(f"Waiting on port {portnum}...")

    t1 = Thread(target=handle_socket, daemon=True)
    t1.start()

    t2 = Thread(target=handle_timer, daemon=True)
    t2.start()

    t3 = Thread(target=handle_print)
    t3.start()

    handle_keyboard()

    t3.join()

    print_queue_messages()

    _socket.close()
