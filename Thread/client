#!/usr/bin/env python3

import setup_path  # pylint: disable=unused-import
import sys
import socket
import random
import time
from threading import Thread, RLock
from queue import Queue
from lib import constants as Constants
from lib import util

_session_id = random.randint(0, 2**32)
_seq = 0
_socket: socket.socket = None
_server_address: "tuple[str,int]" = None
_close_lock = RLock()
_keyboard_lock = RLock()
_socket_lock = RLock()
_client_closing: bool = False
_waiting_message_time: int = -1


def send_packet(command: int, data: str = None):
    global _seq

    data_msg = util.pack(command, _seq, _session_id, data)
    _socket.sendto(data_msg, _server_address)
    _seq += 1


def close_client(send: bool):
    global _client_closing, _waiting_message_time

    with _close_lock:
        if not _client_closing:
            if send:
                _waiting_message_time = time.time()
                send_packet(Constants.Command.GOODBYE.value)
            _client_closing = True
            _keyboard_lock.acquire()


def handle_timer(finish_queue: Queue):
    while True:
        time.sleep(Constants.TIMEOUT_INTERVAL)
        if _waiting_message_time != -1 and time.time() - _waiting_message_time > Constants.TIMEOUT_INTERVAL:
            if not _client_closing:
                print("Timeout")
                _socket_lock.acquire()
                close_client(False)
            break

    finish_queue.put("timer")


def handle_keyboard():
    global _waiting_message_time

    while True:
        text = sys.stdin.readline()
        with _keyboard_lock:
            # Terminates server if input is EOF or "q"
            if not text or (text == "q\n" and sys.stdin.isatty()):
                close_client(True)
                break
            else:
                if _waiting_message_time == -1:
                    _waiting_message_time = time.time()
                send_packet(Constants.Command.DATA.value, text)


def handle_socket(finish_queue: Queue):
    global _waiting_message_time

    def log(session_id: int, seq: "int | None", msg: str):
        if seq is None:
            print(f"0x{session_id:08x} {msg}")
        else:
            print(f"0x{session_id:08x} [{seq}] {msg}")

    while True:
        packet, _ = _socket.recvfrom(Constants.BUFFER_SIZE)
        with _socket_lock:
            magic_num, version, command, seq, session_id = util.unpack(packet)

            if magic_num == Constants.MAGIC_NUMBER and version == Constants.VERSION:
                if command == Constants.Command.GOODBYE.value:
                    log(session_id, seq, "GOODBYE from server.")
                    close_client(False)
                    break
                elif command == Constants.Command.ALIVE.value:
                    if _waiting_message_time != -1:
                        _waiting_message_time = -1
                else:
                    print(f"Invalid command: {command}")
                    close_client(True)
                    break

    finish_queue.put("socket")


def hello_exchange():
    # stop and wait
    def try_hello_exchange(result_queue: Queue):
        send_packet(Constants.Command.HELLO.value)
        while True:
            packet, _ = _socket.recvfrom(Constants.BUFFER_SIZE)
            magic_num, version, command, _, _ = util.unpack(packet)
            if magic_num == Constants.MAGIC_NUMBER and version == Constants.VERSION:
                result_queue.put(command)
                break

    queue = Queue()
    t = Thread(target=try_hello_exchange, args=(queue,), daemon=True)
    t.start()

    try:
        command: int = queue.get(block=True, timeout=Constants.TIMEOUT_INTERVAL)
        return command == Constants.Command.HELLO.value
    except Exception as _:
        return False


def main():
    global _server_address, _socket

    hostname = sys.argv[1]
    portnum = int(sys.argv[2])
    _server_address = (hostname, portnum)
    _socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    if hello_exchange():
        finish_queue = Queue()

        t1 = Thread(target=handle_socket, args=(finish_queue,), daemon=True)
        t1.start()

        t2 = Thread(target=handle_keyboard, daemon=True)
        t2.start()

        t3 = Thread(target=handle_timer, args=(finish_queue,), daemon=True)
        t3.start()

        # blocks current thread until something found in queue
        result = finish_queue.get()
        print(f"Thread finished: {result}")

        try:
            _socket.shutdown(socket.SHUT_RDWR)
        except Exception as _:
            pass
        _socket.close()
    else:
        print("Did not receive HELLO from server")


if __name__ == "__main__":
    main()
